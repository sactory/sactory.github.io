const SIZE = 128;
const CELL_SIZE = 3;
const HEADS = true;
const REPRODUCTION_THRESOLD = .75;

const colors = [
	["grey", "#718096", "#CBD5E0"],
	["red", "#E53E3E", "#FC8181"],
	["orange", "#DD6B20", "#F6AD55"],
	["yellow", "#D69E2E", "#F6E05E"],
	["green", "#38A169", "#68D391"],
	["teal", "#319795", "#4FD1C5"],
	["blue", "#3182CE", "#63B3ED"],
	["indigo", "#5A67D8", "#7F9CF5"],
	["purple", "#805AD5", "#B794F4"],
	["pink", "#D53F8C", "#F687B3"]
];

const rand = () => Math.floor(Math.random() * SIZE);

var rows = [];
for(let i=0; i<SIZE; i++) {
	let row = [];
	for(let j=0; j<SIZE; j++) {
		row.push(0);
	}
	rows.push(row);
}

var results = &[];
var count = & => *results.reduce((acc, {cells}) => acc + cells, 0);

var players = [];

for(let i=0; i<colors.length; i++) {
	players.push({type: i, position: [rand(), rand()]});
}

var canvas, context;

function draw(i, j, type) {
	context.fillStyle = type < 10 ? "#eeeeff" : (type < 20 ? colors[type - 10][HEADS ? 1 : 2] : colors[type - 20][2]);
	context.fillRect(j * CELL_SIZE, i * CELL_SIZE, CELL_SIZE, CELL_SIZE);
}

function tick() {
	players.forEach(player => {
		if(!player.dead) {
			let {type, position: [i, j], prev: [pi, pj] = []} = player;
			let di, dj;
			do {
				[di, dj] = (() => {
					switch(Math.floor(Math.random() * 4)) {
						case 0: return [i - 1, j];
						case 1: return [i + 1, j];
						case 2: return [i, j - 1];
						case 3: return [i, j + 1];
					}
				})();
			} while(di < 0 || di >= SIZE || dj < 0 || dj >= SIZE || (di === pi && dj === pj));
			player.prev = player.position;
			player.position = [di, dj];
			let cell = rows[di][dj];
			draw(i, j, rows[i][j] = type + 20);
			if(cell >= 10 && cell < 20 && cell != type + 10) {
				// kill the other if it has a different type
				players.find(({position: [mi, mj]}) => di == mi && dj == mj).dead = true;
			}
			draw(di, dj, rows[di][dj] = type + 10);
		}
	});
	// filter out dead players
	players = players.filter(player => !player.dead);
	// give birth to new cells
	players.filter(player => !player.infertile).forEach(player => {
		const {type, position} = player;
		let total = 0;
		let owned = 0;
		let check = (i, j) => {
			if(i >= 0 && i < SIZE && j >= 0 && j < SIZE) {
				total++;
				if(rows[i][j] == type + 20) owned++;
			}
		};
		for(let i=-1; i<2; i++) {
			for(let j=-1; j<2; j++) {
				check(position[0] + i, position[1] + j);
			}
		}
		if(owned / total >= REPRODUCTION_THRESOLD) {
			// give birth to another
			players.push({type, position});
			player.infertile = true;
		}
	});
	/*var scores = {};
	rows.forEach(row => row.forEach(type => {
		if(type >= 10) {
			let t = type % 10;
			if(!scores[t]) scores[t] = {
				type: t,
				cells: 0,
				heads: 0
			};
			let ref = scores[t];
			ref.cells++;
			if(type < 20) ref.heads++;
		}
	}));
	*results = Object.values(scores).sort((a, b) => b.cells - a.cells);
	if(*results.length > 1) {*/
		setTimeout(tick, 1000 / 60);
	//}
}

function start() {
	context = canvas.getContext("2d");
	context.fillStyle = "#eef";
	context.fillRect(0, 0, canvas.width, canvas.height);
	players.forEach(({type, position: [i, j]}) => draw(i, j, rows[i][j] = type + 20));
	tick();
}

<style :head>
	foreach(colors as [, head, cell], i) {
		[data-type='1${i}'] < fill, background: ${head};
		[data-type='2${i}'] < fill, background: ${cell};
	}
	
	.scores {
		color: white;
		font-family: Helvetica, monospace;
		white-space: nowrap;
		text-shadow: 0 0 4px rgba(0, 0, 0, .5);
		div {
			padding: 2px 4px;
		}
	}
</style>

<:body>
	<canvas :ref=canvas {width, height}=(SIZE * CELL_SIZE) +documentappend=start />
	<div class="scores">
		foreach(*results as {type, cells, heads}) {
			<div data-type=(20 + type) &width=(cells / ^count * 100 + "%")>${colors[type][0]}: ${cells} (${heads})</div>
		}
	</div>
</:body>