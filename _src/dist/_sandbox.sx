const SIZE = 128;
const CELL_SIZE = 2;

const colors = [
	["grey", "#718096", "#CBD5E0"],
	["red", "#E53E3E", "#FC8181"],
	["orange", "#DD6B20", "#F6AD55"],
	["yellow", "#D69E2E", "#F6E05E"],
	["green", "#38A169", "#68D391"],
	["teal", "#319795", "#4FD1C5"],
	["blue", "#3182CE", "#63B3ED"],
	["indigo", "#5A67D8", "#7F9CF5"],
	["purple", "#805AD5", "#B794F4"],
	["pink", "#D53F8C", "#F687B3"]
];

const rand = () => Math.floor(Math.random() * SIZE);

var rows = [];
for(let i=0; i<SIZE; i++) {
	let row = [];
	for(let j=0; j<SIZE; j++) {
		row.push(0);
	}
	rows.push(row);
}

var results = &[];
var count = & => *results.reduce((acc, {cells}) => acc + cells, 0);

var players = [];

for(let i=0; i<colors.length; i++) {
	players.push({type: i, moves: [[rand(), rand()]]});
}

var canvas, context;

function draw(i, j, type) {
	context.fillStyle = type == 0 ? "#ffffee" : (type < 10 ? "#333333" : (type < 20 ? colors[type - 10][1] : colors[type - 20][2]));
	context.fillRect(j * CELL_SIZE, i * CELL_SIZE, CELL_SIZE, CELL_SIZE);
}

function tick() {
	players.forEach(player => {
		let {type, dead, moves} = player;
		if(!dead) {
			let [i, j] = moves[0];
			let [pi, pj] = moves[1] || []; // previous move, to avoid going back
			let di, dj;
			do {
				[di, dj] = (() => {
					switch(Math.floor(Math.random() * 4)) {
						case 0: return [i - 1, j];
						case 1: return [i + 1, j];
						case 2: return [i, j - 1];
						case 3: return [i, j + 1];
					}
				})();
			} while(di < 0 || di >= SIZE || dj < 0 || dj >= SIZE || (di === pi && dj === pj));
			moves.unshift([di, dj]);
			let cell = rows[di][dj];
			draw(i, j, rows[i][j] = type + 20);
			if(cell == 1 && Math.random() > .75) {
				// trap, player is dead
				player.dead = true;
				draw(di, dj, rows[di][dj] = 0);
			} else {
				if(cell == 1) {
					// zombie captured
					players.push({type, moves: [[di, dj]]});
				} else if(cell >= 10 && cell < 20) {
					// change team
					players.find(({moves: [[mi, mj]]}) => di == mi && dj == mj).type = type;
				}
				draw(di, dj, rows[di][dj] = type + 10);
			}
		}
	});
	var scores = {};
	rows.forEach(row => row.forEach(type => {
		if(type >= 10) {
			let t = type % 10;
			if(!scores[t]) scores[t] = {
				type: t,
				cells: 0,
				heads: 0
			};
			let ref = scores[t];
			ref.cells++;
			if(type < 20) ref.heads++;
		}
	}));
	*results = Object.values(scores).sort((a, b) => b.cells - a.cells);
	if(*results.length > 1) {
		setTimeout(tick, 1000 / 60);
	} else {
		gtimeout = 9999999999999999999999999999999;
	}
}

var gtimeout = Math.pow(2, 15);

function goodieImpl() {
	let i, j, cell;
	do {
		cell = rows[i = rand()][j = rand()];
	} while(cell != 0 && cell < 20);
	draw(i, j, rows[i][j] = 1);
}

function goodie() {
	goodieImpl();
	setTimeout(goodie, Math.max(500, gtimeout /= 2));
}

function start() {
	context = canvas.getContext("2d");
	context.fillStyle = "#eef";
	context.fillRect(0, 0, canvas.width, canvas.height);
	players.forEach(({type, moves: [[i, j]]}) => draw(i, j, *(rows[i][j]) = type + 20));
	for(let i=0; i<(SIZE*SIZE)/25; i++) {
		goodieImpl();
	}
	goodie();
	tick();
}

<style :head>
	[data-type='0'] < fill: #333;
	[data-type='1'] < fill: #333;
	[data-type='2'] < fill: #eef;
	foreach(colors as [, head, cell], i) {
		[data-type='1${i}'] < fill, background: ${head};
		[data-type='2${i}'] < fill, background: ${cell};
	}

	[data-type='1'] {
		//border-radius: 50%;
		//transform: rotate(45deg) scale(${Math.sqrt(2)});
	}
	
	.scores {
		color: white;
		font-family: Helvetica, monospace;
		white-space: nowrap;
		text-shadow: 0 0 4px rgba(0, 0, 0, .5);
		div {
			padding: 2px 4px;
		}
	}
</style>

<:body>
	<canvas :ref=canvas {width, height}=(SIZE * CELL_SIZE) +documentappend=start />
	<div class="scores">
		foreach(*results as {type, cells, heads}) {
			<div data-type=(20 + type) &width=(cells / ^count * 100 + "%")>${colors[type][0]}: ${cells} (${heads})</div>
		}
	</div>
</:body>